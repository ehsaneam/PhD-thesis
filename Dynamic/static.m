clear y x G con psi_p psi_n sigma
if U>0
	y = binvar(D,S,E,'full');							% subcarrier e in RU i used for split s
	x = binvar(U,S,F,'full');							% user u used split s with func f
	
	R_res = loss_gain.*R3;
	P_res = loss_gain.*P3;
	B_res = loss_gain.*B3;

	con = [sum(y,2) == 1, sum(sum(x,3),2) == 1];

	if U_old>0
		psi_p = binvar(U_old,S,F,'full');				% auxiliary variables to linearize if-else constraint
		psi_n = binvar(U_old,S,F,'full');
		sigma = binvar(U_old,S,F,'full');				% punishment for service interruption to change resources
														% available for user
		G = -alpha*sum(sum(sum(x.*R_res))) ...
			-beta*sum(sum(y(:,blocked_con,:),3)) ...
			-gamma*sum(sum(sum(sigma.*(R_res(1:U_old,:,:).*x_old))));
		con = [con, sigma+psi_n+psi_p == 1, ...
			x(1:U_old,:,:)-x_old >= delta*psi_p-psi_n, ...
			x(1:U_old,:,:)-x_old <= psi_p-delta*psi_n];
	else
		G = -alpha*sum(sum(sum(x.*R_res))) ...
			-beta*sum(sum(y(:,blocked_con,:),3));
	end

	if func_state==no_func
		con = [con, x(:,:,do_func) == 0];
	end

	for i=1:D
		j = (i==reg1)*reg21 + (i==reg2)*reg12;			% only for 2 regions
		if ~isempty(u_reg{i}) && ~isempty(u_reg{j})
			con = [con, P_0(i) + sum(sum(sum(x(u_reg{i},:,:).* ...
						P_res(u_reg{i},:,:)))) + ...
						sum(x(u_reg{j},split7_1,do_func).* ...
						P_res(u_reg{j},split7_1,do_func))<=P_RU];
			con = [con, B_0(i) + sum(sum(sum(x(u_reg{i},:,:).* ...
						B_res(u_reg{i},:,:)))) + ...
						sum(x(u_reg{j},split7_1,do_func).* ...
						B_res(u_reg{j},split7_1,do_func))<=B_RU];
			con = [con, T_0(i,split7_1) + sum(sum(x(u_reg{i},split7_1,:).* ...
						T3(u_reg{i}, split7_1,:),3)) + ...
						sum(x(u_reg{j},split7_1,do_func).* ...
						T3(u_reg{j},split7_1,do_func)) <= T_RU/E* ...
						sum(y(i,split7_1,:),3)];
			con = [con, T_0(i,split2) + sum(sum(x(u_reg{i},split2,:).* ...
						T3(u_reg{i}, split2,:),3)) <= T_RU/E* ...
						sum(y(i,split2,:),3)];
		elseif isempty(u_reg{i}) && ~isempty(u_reg{j})
			con = [con, P_0(i) + sum(x(u_reg{j},split7_1,do_func).* ...
						P_res(u_reg{j},split7_1,do_func))<=P_RU];
			con = [con, B_0(i) + sum(x(u_reg{j},split7_1,do_func).* ...
						B_res(u_reg{j},split7_1,do_func))<=B_RU];
			con = [con, T_0(i,split7_1) + sum(x(u_reg{j},split7_1,do_func).* ...
						T3(u_reg{j},split7_1,do_func)) <= T_RU/E* ...
						sum(y(i,split7_1,:),3)];
		elseif ~isempty(u_reg{i}) && isempty(u_reg{j})
			con = [con, P_0(i) + sum(sum(sum(x(u_reg{i},:,:).* ...
						P_res(u_reg{i},:,:)))) <= P_RU];
			con = [con, B_0(i) + sum(sum(sum(x(u_reg{i},:,:).* ...
						B_res(u_reg{i},:,:)))) <= B_RU];
			con = [con, T_0(i,split7_1) + sum(sum(x(u_reg{i},split7_1,:).* ...
						T3(u_reg{i}, split7_1,:),3)) <= T_RU/E* ...
						sum(y(i,split7_1,:),3)];
			con = [con, T_0(i,split2) + sum(sum(x(u_reg{i},split2,:).* ...
						T3(u_reg{i}, split2,:),3)) <= T_RU/E* ...
						sum(y(i,split2,:),3)];
		end
	end

	options = sdpsettings('solver', 'cplex', 'verbose',1, 'debug', 1, ...
		'warning', 1, 'removeequalities', 0, 'showprogress', 1, 'cplex.timelimit', 200);
	results = optimize(con, G, options);

	if results.problem~=0
		input('Error: Cannot find a solution, infeasible problem.');
	end
end